{"version":3,"sources":["../node_modules/@turf/area/dist/es/index.js"],"names":["RADIUS","area","geojson","geomReduce","value","geom","i","total","type","polygonArea","coordinates","length","calculateArea","coords","Math","abs","ringArea","p1","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","num","PI"],"mappings":"4HAAA,4DAEIA,EAAS,QAgBE,SAASC,EAAKC,GACzB,OAAOC,YAAWD,GAAS,SAAUE,EAAOC,GACxC,OAAOD,EAUf,SAAuBC,GACnB,IACIC,EADAC,EAAQ,EAEZ,OAAQF,EAAKG,MACT,IAAK,UACD,OAAOC,EAAYJ,EAAKK,aAC5B,IAAK,eACD,IAAKJ,EAAI,EAAGA,EAAID,EAAKK,YAAYC,OAAQL,IACrCC,GAASE,EAAYJ,EAAKK,YAAYJ,IAE1C,OAAOC,EACX,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,kBACD,OAAO,EAEf,OAAO,EA3BYK,CAAcP,KAC9B,GA4BP,SAASI,EAAYI,GACjB,IAAIN,EAAQ,EACZ,GAAIM,GAAUA,EAAOF,OAAS,EAAG,CAC7BJ,GAASO,KAAKC,IAAIC,EAASH,EAAO,KAClC,IAAK,IAAIP,EAAI,EAAGA,EAAIO,EAAOF,OAAQL,IAC/BC,GAASO,KAAKC,IAAIC,EAASH,EAAOP,KAG1C,OAAOC,EAeX,SAASS,EAASH,GACd,IAAII,EACAC,EAEAC,EACAC,EACAC,EACAf,EACAC,EAAQ,EACRe,EAAeT,EAAOF,OAC1B,GAAIW,EAAe,EAAG,CAClB,IAAKhB,EAAI,EAAGA,EAAIgB,EAAchB,IACtBA,IAAMgB,EAAe,GAErBH,EAAaG,EAAe,EAC5BF,EAAcE,EAAe,EAC7BD,EAAa,GAERf,IAAMgB,EAAe,GAE1BH,EAAaG,EAAe,EAC5BF,EAAc,EACdC,EAAa,IAIbF,EAAab,EACbc,EAAcd,EAAI,EAClBe,EAAaf,EAAI,GAErBW,EAAKJ,EAAOM,GACZD,EAAKL,EAAOO,GAEZb,IAAUgB,EADLV,EAAOQ,GACK,IAAME,EAAIN,EAAG,KAAOH,KAAKU,IAAID,EAAIL,EAAG,KAEzDX,EAASA,EAAQP,EAASA,EAAU,EAExC,OAAOO,EAEX,SAASgB,EAAIE,GACT,OAAQA,EAAMX,KAAKY,GAAM","file":"static/js/4.d817e324.chunk.js","sourcesContent":["import { geomReduce } from \"@turf/meta\";\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nexport default function area(geojson) {\n    return geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                // i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                // i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = (total * RADIUS * RADIUS) / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return (num * Math.PI) / 180;\n}\n"],"sourceRoot":""}